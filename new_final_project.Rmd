---
title: "New_final_project"
author: "Haokun Zhang, Zhang Lu, Jonathan"
date: '2023/04/21'
output: bookdown::pdf_document2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
```{r warning=FALSE, echo=FALSE, message=FALSE, alert=FALSE}
# loaded the needed packages and read the data
library(ggplot2)
library(caret)
library(car)
library(factoextra)
library(randomForest)
library(rfUtilities)
library(rsample)
library(multcomp) 
library(cluster) 

df <- read.csv("https://raw.githubusercontent.com/haokunz/Data_mining_project/main/data/internal_controls_data_0421.csv",
               header = TRUE)

```



```{r warning=FALSE, echo=FALSE, message=FALSE, alert=FALSE}
# Step 2. Data wrangling
# delete copyright and lines of notes
df <- df[-c(nrow(df), nrow(df)-1), ]

# remove records with restated internal control report
duplicated_indexes <- which(df$Restated.Internal.Control.Report == "Yes (1)")
duplicated_companies <- unique(df$Company[duplicated_indexes])
restate_indexes <- which(df$Company %in% duplicated_companies)
remove_index <- setdiff(restate_indexes, duplicated_indexes)
df1 <- df[-remove_index, ]

# remove duplicated records from different auditors working at the same time
multi_auditors <- table(df1$Company)[table(df1$Company) >= 2]
remove_index_2 <- setdiff(which(df1$Company %in% names(multi_auditors)), match(names(multi_auditors), df1$Company))
df2 <- df1[-remove_index_2, ]

# remove rows with missing revenue data
df2 <- df2[df2$Revenue.... != "", ]

# select target columns
df3 <- df2[ ,c("Company", "City", "State.Code", "State.Name", "State.Region", 
               "Auditor", "Auditor.Key", "Auditor.State.Name", 
               "Effective.Internal.Controls", "Audit.Fees....", "Non.Audit.Fees....",
               "Total.Fees....", "Share.Price", "Market.Cap....", "Revenue....",
               "Earnings....", "Book.Value....", "Assets....")]

# change column names to mark the targets
colnames(df3) <- c("company", "city", "state_code", "state_name", "state_region",
                   "auditor", "auditor_key", "auditor_state_name", 
                   "effective_internal_controls", "audit_fees", "non_audit_fees",
                   "total_fees", "share_price", "market_cap","revenue",
                   "earnings", "book_value", "assets")

# convert money amount character into numeric
df3$audit_fees = as.numeric(gsub(",", "", df3$audit_fees))
df3$non_audit_fees = as.numeric(gsub(",", "", df3$non_audit_fees))
df3$total_fees = as.numeric(gsub(",", "", df3$total_fees))
df3$market_cap = as.numeric(gsub(",", "", df3$market_cap))
df3$revenue = as.numeric(gsub(",", "", df3$revenue))
df3$earnings = as.numeric(gsub(",", "", df3$earnings))
df3$book_value = as.numeric(gsub(",", "", df3$book_value))
df3$assets = as.numeric(gsub(",", "", df3$assets))

# add indicator for analysis
df3$big_four_indicator <- ifelse(df3$auditor_key <= 4, 1, 0)
df3$five_category <- ifelse(df3$auditor_key < 5, df3$auditor_key, 5)
df3$audit_percent <- df3$audit_fees / df3$total_fees

# add transformation variables to the data
df3$audit_fees_bc <- predict(BoxCoxTrans(df3$audit_fees), df3$audit_fees)
non_audit_bc <- predict(BoxCoxTrans(df3$non_audit_fees[df3$non_audit_fees!=0]),
                        df3$non_audit_fees[df3$non_audit_fees!=0])
df3$total_fees_bc <- predict(BoxCoxTrans(df3$total_fees), df3$total_fees)
df3$market_cap_bc <- predict(BoxCoxTrans(df3$market_cap), df3$market_cap)
df3$market_fee_ratio <- log(df3$total_fees/ df3$market_cap)
df3$assets_log <- log(df3$assets)

revenue_0 = jitter(df3$revenue)
df3$revenue_trans <- (revenue_0/abs(revenue_0)) * log(abs(df3$revenue) + 1)
mean((revenue_0/abs(revenue_0)))

earnings_0 = jitter(df3$earnings)
df3$earnings_trans <- (earnings_0/abs(earnings_0)) * log(abs(df3$earnings) + 1)

# change columns to factors
df3$big_4_factor <- as.factor(df3$big_four_indicator)
df3$five_category_factor <- as.factor(df3$five_category)
df3$state_region <- as.factor(df3$state_region)




```

# Data visualization(EDA)
Plot 1: plot the number distribution of companies in different regions
\flushleft
```{r warning=FALSE, echo=FALSE, message=FALSE, alert=FALSE}
# Step 3. Data Visualization(EDA - Exploratory Data Analysis) 
# basic plots, preliminary exploration #
# plot the number distribution of companies in different regions
company_numbers <- sort(table(df3$state_region[df3$state_region != ""]), decreasing = FALSE, na.last = NA)

par(mar = c(5.1, 6.5, 4.1, 2.1))
barplot(height=company_numbers,
        names.arg=c("Canada", "US_NewEng", "US_Southwest", "US_Southeast",
                    "US_Midwest", "Foreign", "US_MAtlan", "US_West"),
        col="#69b3a2", horiz=TRUE, las = 1, main = "Num. of Companies", xlab = "numbers")
par(mar = c(5.1, 4.1, 4.1, 2.1))

```

Plot 2: Use eight plots to display the effect of transformation on fee related variables
\flushleft
```{r warning=FALSE, echo=FALSE, message=FALSE, alert=FALSE}
# use eight plots to display the effect of transformation on fee related variables
par(mfrow = c(2, 4))
hist(df3$audit_fees, breaks="Scott", main="audit fees", xlab="Audit fees")
hist(df3$audit_fees_bc, main="audit fees (transformed)", xlab="Audit fees")
hist(df3$non_audit_fees, breaks="Scott", main="non audit fees", xlab="Non-audit fees")
hist(non_audit_bc, main="non audit fees (transformed)", xlab="Non-audit fees")
hist(df3$total_fees, breaks="Scott", main="total fees", xlab="Total fees")
hist(df3$total_fees_bc, main="total fees (transformed)", xlab="Total fees")
hist(df3$market_cap, breaks="Scott", main="Market cap", xlab="Market cap")
hist(df3$market_cap_bc, main="Market cap (transformed)", xlab="Market cap")
par(mfrow = c(1, 1))




```

Plot 3: Use three plots to display the categorical data
\flushleft
```{r warning=FALSE, echo=FALSE, message=FALSE, alert=FALSE}
# use three plots to display the categorical data
par(mfrow = c(1, 3))
barplot(table(df3$five_category_factor), ylab = "Frequency", main="Auditing company distribution")
barplot(table(df3$big_4_factor), yaxt='n', ylab="Frequency", main="Num. big4 vs. other")
axis(side=2, at=seq(0, nrow(df3), 200))
barplot(table(df3$effective_internal_controls), yaxt='n', ylab="Frequency", main="Num. effective internal controls")
axis(side=2, at=seq(0, nrow(df3), 200))
par(mfrow = c(1, 1))


```

Plot 4. Plot the transformed company market cap, total auditing fees, and effective internal control
\flushleft
```{r warning=FALSE, echo=FALSE, message=FALSE, alert=FALSE}
# plot the transformed company market cap, total auditing fees, and effective internal control
sp = ggplot(df3, aes(x=market_cap_bc, y=five_category_factor,
                     group=effective_internal_controls)) +
     geom_point(aes(color=effective_internal_controls), size=0.9,
                    position=position_dodge2(0.3))

labels = as.vector(outer(rep("Num. of 'No'="), table(df3$effective_internal_controls,
                                           df3$five_category_factor)[1,],
                         paste, sep=""))
sp + annotate(geom="text", x=rep(27.5, 5), y=seq(0.7, 4.7, 1), label= labels) 

```

Plot 5: Plot the transformed company market cap vs. total auditing fees
\flushleft
```{r warning=FALSE, echo=FALSE, message=FALSE, alert=FALSE}
# plot the transformed company market cap vs. total auditing fees
ggplot(df3, aes(x=market_cap_bc, y=total_fees_bc, group=five_category_factor)) +
  geom_point(aes(color=five_category_factor), size=0.9)

cor(df3$market_cap_bc, df3$total_fees_bc)

```

Plot 6: Plot the auditing fees
\flushleft
```{r warning=FALSE, echo=FALSE, message=FALSE, alert=FALSE}
# plot the auditing fees
#ggplot(df3, aes(x=five_category_factor, y=total_fees_bc)) + 
#  geom_violin(trim=FALSE, fill="gray")+
#  labs(title="Auditing fees",x="category", y = "total fees")+
#  geom_boxplot(width=0.3)+
#  theme_classic()
# Change color by groups
dp <- ggplot(df3, aes(x=five_category_factor, y=total_fees_bc, fill=five_category_factor)) + 
  geom_violin(trim=FALSE)+
  geom_boxplot(width=0.3, fill="white")+
  labs(title="Plot of auditing fees",x="category", y = "total fees")
dp + theme_classic()

```


# Perform a statistical test here to compare big4 vs non big4 when considering
\flushleft
```{r warning=FALSE, echo=FALSE, message=FALSE, alert=FALSE}
# perform a statistical test here to compare big4 vs non big4 when considering
# market cap as covariate 

# perform analysis of variance for 1-5 auditing company levels(ANOVA)
m5_ancova = lm(total_fees_bc ~ five_category_factor + market_cap_bc +
              five_category_factor*market_cap_bc, df3)
Anova(m5_ancova, type=3)

multi_comarisons <- lm(total_fees_bc ~ five_category_factor + market_cap_bc, df3)
postHocs <- glht(multi_comarisons, linfct=mcp(five_category_factor="Tukey")) # generalize linear hypothesis test
summary(postHocs)
plot(postHocs)

```


## Unsupervised Learning: Clustering
\flushleft
After exploring the data set, we continued to cluster with the companies based on the following values before and after previous transformation: audit fees(\$), total fees(\$), Market capitalization(\$), market-fee ratio, asset value(\$), revenue(\$) and earnings(\$). We used the Gap Statistic and K-means methods to determine the number of clusters.
# Gap Statistic for Estimating the Number of Clusters
This method estimates a goodness of clustering measure, the "gap" statistic with a given range of number of clusters K. For each K, it compares the log value of dispersion of observations within a cluster to the estimated log value of dispersion. In this report, the maximum number of clusters to consider is 10. 
```{r fig8, fig.align='center', fig.cap="Gap Statistic Clustering Result" warning=FALSE, echo=FALSE, message=FALSE, alert=FALSE, results= FALSE, fig.keep='all'}
set.seed(143) # same random values are produced each time you run the code
pca_data = na.omit(df3[ ,c("audit_fees_bc", "total_fees_bc", "market_cap_bc",
                           "market_fee_ratio", "assets_log", "revenue_trans",
                           "earnings_trans")])

pca_data_2 = na.omit(df3[ ,c("audit_fees", "total_fees", "market_cap",
                           "market_fee_ratio", "assets", "revenue",
                           "earnings")])

gap_stat <- clusGap(pca_data, FUN = kmeans, nstart = 25,
                    K.max = 10, B = 50)
print(gap_stat, method = "firstmax")
fviz_gap_stat(gap_stat)

```
As The Figure \ref@(fig: fig8) suggests, the Gap statistic estimates that the optimal number of clusters is 2

# K-means Clustering
The K-means clustering uses a principal component analysis to create clusters, and classify and partition objects into multiple groups. The objects are as similar as possible within, and as dissimilar to the objects in other groups as possible. K represents the number of groups. From the previous result, we select 2 sets of groups, with the same variables as Gap statistic used.  
```{r fig9, fig.align='center', fig.cap="K-means Clustering Result of Untransformed Data" warning=FALSE, echo=FALSE, message=FALSE, alert=FALSE}
km.res <- kmeans(pca_data, 2, nstart=25) # k-means clustering

clusters <- data.frame(aggregate(pca_data, by=list(cluster=km.res$cluster), mean)) # get the summary statistics of the data by group.
knitr::kable(clusters,
             caption = "Features of K-means Clustering Groups",
             digits = 3)

dd <- cbind(pca_data, cluster=km.res$cluster)

km.res_2 <- kmeans(pca_data_2, 2, nstart=25) # k-means clustering

clusters_2 <- data.frame(aggregate(pca_data_2, by=list(cluster=km.res_2$cluster), mean)) # get the summary statistics of the data by group.
knitr::kable(clusters_2,
             caption = "Untransformed Features of K-means Clustering Groups",
             digits = 3)

dd <- cbind(pca_data_2, cluster=km.res_2$cluster)

fviz_cluster(km.res, data=pca_data)
```
The K-means clustering aggregated 2 clusters that have distinct features. The Figure \ref@(fig:fig9) shows that these two groups overlap each other in large areas, which is expected because the box-cox and natural log transformation transformed value of the data to be closer to each other. Unsatisfied with the result, we conducted the same clustering with original data.

As shown in Table \ref@(table:table2), companies in cluster 2 have smaller market caps and assets than companies in cluster 1. In cluster 1, the mean asset value is \$2.2 trillion and mean market capitalization is 1.2 trillion. Cluster 2 has mean value of asset worth \$0.2 trillion and 0.17 trillion market capitalization. As a result of less market capitalization, companies in cluster 2 have a mean market-fee ratio of 0.12% while companies in the second cluster has 0.06%. The cluster 2 also has less revenue and earnings than cluster 1. For instance, mean revenue of cluster 2 is approximately \$0.78 trillion while the mean revenue of cluster 2 is \$5.2 trillion. 

In the cluster plot, The component of the first principal component accounts for 55.8% of the total variation, and the second principal component accounts for 19.4%. Together they explain 75.2% variation in the data set. The limited number of variables selected when clustering can explain this issue. Along with variables that have similar values to each other after transformation, the same reason could explain the large area that clusters overlap each other in Figure \ref@(fig:fig9). The overlapped area is smaller in Fig \ref@(fig:fig10) and the clusters are more distinctive.
```{r fig10, fig.align='center', fig.cap="K-means Clustering Result of Untransformed Data" warning=FALSE, echo=FALSE, message=FALSE, alert=FALSE}
fviz_cluster(km.res_2, data=pca_data_2)
```

```{r warning=FALSE, echo=FALSE, message=FALSE, alert=FALSE}
# Step 6 & 7: Model training and assess the model performance

# compare models with 5-fold cross-validation
## Model building and use k-fold cv(k =5)
tc <- trainControl(method="cv", number=5)
lm_cv <- train(total_fees_bc ~ five_category_factor + state_region + 
                 market_cap_bc + assets_log + revenue_trans + earnings_trans, data=df3,
               method="lm", trControl=tc)

knn_cv <- train(total_fees_bc ~ five_category_factor + state_region + 
                  market_cap_bc + assets_log + revenue_trans + earnings_trans, data=df3,
                method="knn", trControl=tc, tuneLength=20)

rf_cv <- train(total_fees_bc ~ five_category_factor + state_region + 
                 market_cap_bc + assets_log + revenue_trans + earnings_trans, data=df3,
               method="rf", trControl=tc, tuneLength=10)

cart_cv <- train(total_fees_bc ~ five_category_factor + state_region + 
                   market_cap_bc + assets_log + revenue_trans + earnings_trans, data=df3,
                 method="rpart", trControl=tc, tuneLength=10)

gbm_cv <- train(total_fees_bc ~ five_category_factor + state_region + 
                  market_cap_bc + assets_log + revenue_trans + earnings_trans, data=df3,
                method="gbm", trControl=tc, tuneLength=10, verbose=FALSE)

# Assess the model performance
model_list <- list(lm = lm_cv, knn = knn_cv, rf = rf_cv, cart = cart_cv, gbm = gbm_cv)
res = resamples(model_list) # rsample: take randomly drawn (sub)samples of the sample and calculate the statistic from that (sub)sample
summary(res) # the higher is R-square is better

```
Depend on the above figure, we can see that random forest has the best performance, which has the lowest MAE, lowest RMSE and highest R-square.

So we choose Random Forest model to do the prediction of Total auditing fee based on other variables.
```{r warning=FALSE, echo=FALSE, message=FALSE, alert=FALSE}
# Choose the best performance model，use it to do the prediction，並且將結果圖表化？ Partial dependence plots etc

# predict the total auditing fee based on other variables
set.seed(2501)
data_split = initial_split(df3, prop=0.8)
data_train = training(data_split)
data_test = testing(data_split)

rf1 <- randomForest(total_fees_bc ~ five_category_factor + state_region + 
                      market_cap_bc + assets_log + revenue_trans + earnings_trans,
                    data=data_train, importance=TRUE)

rf1
plot(rf1)
modelr::rmse(rf1, data_test)
varImpPlot(rf1, type=1)
rf_predict <- predict(rf1, data_test)

RSQUARE = function(y_actual,y_predict){
  cor(y_actual,y_predict)^2
}

R2 <- RSQUARE(data_test$audit_fees_bc, rf_predict)
```
the explanation of plot(rf1):
the explanation of varImpPlot(rf1, type=1):

```{r warning=FALSE, echo=FALSE, message=FALSE, alert=FALSE}

# plot predicted vs. actual values
plot(x=rf_predict, y= data_test$audit_fees_bc, xlab="Predicted Values",
     ylab="Actual Values", main="Predicted vs. Actual Values")
# add diagonal line for estimated regression line
abline(a=0, b=1)
mylabel =  bquote(italic(R)^2 == .(format(R2, digits = 3)))
legend("topleft", legend=mylabel)
```
the explanation of predict v.s. actual values

We add the diagonal line for estimated regression line here.

```{r warning=FALSE, echo=FALSE, message=FALSE, alert=FALSE}
Predict_state1 = predict(df3$total_fees_bc, "revenue_trans", 1 )
Predict_GrennC2 = predict(df3$total_fees_bc, )
Diff_0to1=Predict_GrennC1-Predict_GrennC0


```

```{r warning=FALSE, echo=FALSE, message=FALSE, alert=FALSE}





```

```{r warning=FALSE, echo=FALSE, message=FALSE, alert=FALSE}





```

```{r warning=FALSE, echo=FALSE, message=FALSE, alert=FALSE}





```

```{r warning=FALSE, echo=FALSE, message=FALSE, alert=FALSE}





```

```{r warning=FALSE, echo=FALSE, message=FALSE, alert=FALSE}





```